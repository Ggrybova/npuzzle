Цель этого проекта - решить игру N-puzzle, используя алгоритм поиска A * или один из его вариантов.
Вы начинаете с квадратной доски, состоящей из N * N клеток. Одна из этих ячеек будет пустой, остальные будут содержать числа, начиная с 1, которые будут уникальными в данном случае головоломки.
Ваш алгоритм поиска должен будет найти правильную последовательность ходов, чтобы достичь конечного состояния, a.k.a «решение улитки», которое зависит от размера головоломки (пример ниже). Несмотря на то, что в этом случае проекта не будет прямой оценки его эффективности, он должен иметь по меньшей мере смутно разумную производительность: потратить несколько секунд, чтобы решить 3-головоломку, - десять секунд, что недопустимо.
Единственное движение, которое можно сделать в N-головоломке, - это поменять пустую ячейку с одним из ее соседей (конечно, без диагоналей. Представьте, что вы перемещаете блок с номером на пустое место).

Что ты должен сделать
Реализуйте алгоритм поиска A * (или один из его вариантов, который вы можете выбрать), чтобы решить N-головоломку, со следующими ограничениями:

• Вы должны управлять различными размерами головоломки (3, 4, 5, 17 и т. Д.). Чем выше ваша программа может пройти без смерти ужасной, ужасной смерти, тем лучше.
• Вы должны управлять как случайно определенными состояниями (вашего собственного поколения, конечно), так и входными файлами, которые задают стартовую доску, формат которой описан в приложении.
• Стоимость, связанная с каждым переходом, всегда равна 1.
• Пользователь должен иметь возможность выбирать между как минимум 3 (соответствующими) эвристическими функциями.
Эвристика Манхэттенского расстояния обязательна, остальные два зависят от вас. Под «релевантным» мы подразумеваем, что они должны быть допустимыми (прочитайте, что это значит), и они должны быть чем-то иным, чем «просто возвращать случайное значение, потому что #YOLO».
• В конце поиска программа должна предоставить следующие значения:
	◦ Общее количество когда-либо выбранных состояний в «открытом» наборе (сложность во времени)
	◦ Максимальное количество состояний, когда-либо представленных в памяти одновременно во время поиска (сложность по размеру)
	◦ Количество ходов, необходимое для перехода из исходного состояния в конечное состояние, в соответствии с поиском
	◦ Упорядоченная последовательность состояний, составляющих решение, согласно поиску
	◦ Puzzle Загадка может быть неразрешимой, в этом случае вы должны сообщить пользователю и выйти

Бонусы
• Сконфигурируйте соответствующие функции g (x) и h (x) для запуска поиска с одинаковой стоимостью и жадного поиска. Выполните с тем же выводом (Конечно, решение может быть другим. Узнайте, почему, в этом суть.)

Защитные сессии
Для сеанса защиты будьте готовы:
• Объясните свою реализацию алгоритма поиска, самое главное объясните, какой это вариант A * и почему вы его выбрали. Если вы не можете объяснить это, вы можете даже не реализовать это.
• Объясните свой выбор эвристики и покажите, что они допустимы. То же, что и в предыдущем пункте: если вы не можете это объяснить, не стоит его реализовывать.
• Обоснуйте свой выбор с точки зрения структур данных
• Фактически запустите вашу программу на примерах разных размеров, которые демонстрируют вашу успешную реализацию проекта. От вас ожидают привести несколько примеров защиты.

> cat -e npuzzle-3-1.txt
# this is a comment$
3$
3 2 6 #another comment$
1 4 0$
8 7 5$

> cat -e npuzzle-4-1.txt
# PONIES$
4$
0 10 5 7$
11 14 4 8$
1 2 6 13$
12 3 15 9$

> cat -e npuzzle-4-1.txt
# Puzzles can be aligned, or NOT. whatever. accept both.$
4$
0 10 5 7$
11 14 4 8$
1 2 6 13$
12 3 15 9$

-------------------------------------------------------------------------------

https://www.youtube.com/watch?v=AsEC2TJZ3JY

c(my_a_star).
my_a_star:a_star({1,1},{3,3}).

Opened = ets:new(open, [bag]).
ets:insert(Opened, {1,1}).	
ets:tab2list(Opened).
GWeight0 = dict:store({1,1}, 3, dict:new()).
GWeight = dict:store({1,2}, 2, dict:new()).
dict:to_list(GWeight0).

my_a_star:min_weight(Opened, GWeight0).









